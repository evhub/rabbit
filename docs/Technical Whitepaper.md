Rabbit Technical Whitepaper
===========================

Functional programming has been found to offer tremendous benefits to the programmer—but most existing functional programming languages are difficult to learn and write code for. A new, modern, functional, interpreted, dynamically-typed, open-source, Turing-complete, scripting language written by the author, the Rabbit programming language, is presented as the solution to this problem—a functional programming language built to be easy to learn and write code for while also providing for the power of functional programming. By using the existing standard libraries for the Python programming language, it is hoped that Rabbit will be able to bring functional programming into the new realm of scripting programming languages.

This paper will be dedicated to a specification of the Rabbit programming language.

The choice was made by the author for Rabbit to be based on Python. Because of Python’s established nature as a scripting language, by using the same libraries and allowing for interoperability with Python code, the goal is that Python will provide Rabbit with an existing scripting framework that it can fit neatly into. The entire Rabbit interpreter is written in pure, version-agnostic, dependency-free Python, able to be run out of the box with nothing extra to install on any Python interpreter. As of this writing, the Rabbit interpreter has been tested and found to be working with no modifications on Python 2.6.9, 2.7.8, 3.2.5, 3.3.5, and 3.4.1. While all tests were performed using CPython, Rabbit should work just as well on Jython, IronPython, PyPy, Cython, or any other full-featured Python interpreter or compiler.

Rabbit is, at its core, a functional programming language. That means all the built-in Rabbit data types are immutable, variable reassignment raises an error, all functions are first-class objects, and higher-order functions are both provided and encouraged. But Rabbit is also a scripting language. That means that Rabbit supports dynamically typed operations and function arguments and cleanly integrated input/output. Rabbit is also a very extensible language, both due to the meta-programming tools it provides, and the ability to write Python code to change and control it. This combination, together with the ability to make use of Python’s extensive existing libraries, makes Rabbit a very useful language for any of the everyday programming tasks that Python is useful for. Rabbit’s use of the Python standard libraries also gives it more freedom to be different with its syntax without putting too high of a learning burden on the new programmer who knows at least some of the Python standard libraries.

Rabbit’s syntax is evaluated in three stages: pre-processing and formatting, evaluation of operators, and evaluation of terms. This paper will cover Rabbit’s basic syntactical constructs, and then go through all of Rabbit’s syntax, using Rabbit’s different data types as a guide. For each type, a description of how the type is constructed, and the different allowable operations on the type, will be given.

### Syntax

Rabbit’s basic syntax is intended to be easy to write, and, if the construct exists in mathematics, similar to the equivalent mathematical notation. A Rabbit source file, always encoded in UTF-8, is separated into a series of commands by the line breaks. Comments are denoted by a pound character and continue until the end of the literal line, as in Python. No special syntax is reserved only for the top-level of a command. All Rabbit’s syntactical constructs are allowed in all parts of the code. Each command simply serves as a thing that will be evaluated that can contain syntactical constructs. If, as is very commonly the case, the programmer wants to span one command over multiple lines, Rabbit will connect any lines that begin with whitespace to those preceding them. The whitespace is kept, however, and is used by certain constructs—such as code blocks or statements—to determine where things begin and end, and the indentation is used to determine what is subservient to what. If the opposite is needed, and multiple commands are wanted on a single line, the double-semicolon operator is used, which will evaluate each of its operands as a command and return the result of the final one. The double-semicolon operator is also special in that it respects whitespace—double semicolon operators at lower indentation levels are left untouched until that indentation level is reached in evaluation. To parse indentation—not just for the double-semicolon operator—the special reserved Unicode markers double dagger (for an indent) and dagger (for a dedent) are used. If the programmer wants to manually enter those markers instead of having them added automatically, they should set off the part of the statement they don’t want that done to with another reserved Unicode character, the pilcrow. Other than for indentation, string literals, and in-between words (which can either mean a variable name with space in it or an automatic multiplication or function call), whitespace is ignored. Additionally, while it doesn’t mark indentation, another special Unicode marker symbol, the section symbol, is also used in Rabbit, and is used in pairs with a number between the two symbols, the number being that of the parenthetical that the section symbol pair is supposed to represent.

Variable assignment in Rabbit is much like in other languages, with the change that the evaluation of the value of the variable is deferred until later by default. This is done both as an optimization and to allow functions like `Meta.unused` to exist that can tell the programmer whether or not a variable has ever been used. This form is lazy assignment, where a variable is bound to a piece of code that will be evaluated when the value of the variable is needed, and is done via the equals operator. Direct assignment, where a variable is bound to the result of evaluating a piece of code, is done via the colon-equals operator. Neither operator, however, will allow a variable to be redefined unless it is being redefined to exactly its current value, or a special impure function, `def`, is used. Rabbit variable names may be made up of lowercase letters, uppercase letters, underscores, single quotation marks (used to represent prime), and may also contain numbers and spaces, but variable names containing numbers and spaces may need to be enclosed in parentheses when referenced to prevent the interpreter from treating each part as separate. Variable names may also never contain all numbers. In addition to ASCII characters, Unicode characters are also allowed in variable names, aside from the reserved Unicode characters `λ`, `≠`, `«`, `»`, `§`, `¶`, `†`, `‡`, `“`, and `”`. Finally, Rabbit also supports assignment to lists of variable names, which will break up the result and attempt to assign its parts to each part of the variable name list, grouping extra items in the last variable.

Rabbit’s functional features are built right into its basic syntax. When first evaluating a file or input from a console, side-effect producing functions are available for the programmer to call just like any other function. All functions are call-by-value and all Rabbit code is evaluated linearly from top to bottom, in sequence, to make imperative-style calling of side-effect producing functions easy. To simultaneously also allow for all of the benefits of referentially transparent code, Rabbit provides the programmer with pure toggles, represented as a line containing nothing but hyphens (at least three of them), that allow the programmer to signify that they are entering or exiting a piece of code where they want the absence of side-effects to be strictly enforced. Rabbit also provides a function, `pure`, that will execute the code it is given inside of a pure block. These utilities allow programmers to take full advantage of the benefits of referential transparency without having to sacrifice ease of input/output. This paper recommends, as best practice in writing Rabbit code, that no more than two pure toggles be used in one file, allowing the file to be set up in a header-body-footer style that makes it easily apparent where referential transparency is enforced (the body), and where imports and requirements (the header) and input/output (the footer) are done.

Just like in all programming languages, sometimes errors can occur, and Rabbit provides tools for error handling and debugging. For error handling, Rabbit provides the `raise`, `try`, and `except` functions for, respectively, raising an error, catching an error, and filtering errors by type. Errors in Rabbit are represented as objects with special attributes describing special things about them, the most important being their `name`. Most names of Rabbit errors match those in Python, but some are changed for clarity, or for distinguishing between the Python version of the error and the Rabbit version of the error. `SyntaxError`, for example, means a Rabbit syntax error, whereas Python’s SyntaxError shows up as `PythonSyntaxError`. To assist in debugging, Rabbit attempts to provide as much information as it can in its tracebacks, showing the entire route of the command through all of the calls that are made on it or parts of it, and all the intermediate values returned from the evaluation of those parts. The syntax for tracebacks is fairly complicated, but the basic idea—use a symbol to represent a type of call, and for displaying the call put that symbol before the argument to the call, optionally with some extra information about the call after it, then for the result of the call show the result, then the reverse of the symbol, then the original argument. Fatal errors are displayed with two exclamation marks, and non-fatal errors (warnings) are displayed with one exclamation mark.

### Integers and Numbers

Rabbit has two basic numerical types: integers and numbers. Rabbit integers are simply Python integers. Like Python integers, Rabbit integers support infinite precision. Unlike Python 2, however, but like Python 3, all integers are considered the same type, even if the underlying implementation is different (long or short integers). Integers in Rabbit are declared by writing them out in decimal, followed by an optional decimal point and optional zeroes. Rabbit numbers are simply Python floats. Like Python floats, Rabbit numbers are always double-precision. Numbers in Rabbit are declared by writing them out in decimal, followed by a decimal point and a fractional part. The basic syntax for declaring numbers does not support scientific notation, but this can easily be achieved either through multiplication or the `Math.E` function provided for that purpose.

Both integers and numbers support a variety of different operations. Addition uses the plus operator, subtraction and negation share the minus operator, with subtraction being binary and negation being unary. As precedence increases, each at their own precedence level, modulo is represented using the percent sign operator, and floor division is represented using the double-slash operator. The next highest precedence level features multiplication and division, multiplication represented using the asterisk operator, and division represented using the slash operator. Normal divison in Rabbit always works like Python 3 division, returning as exact a result as possible. Finally, exponentiation, at a much higher precedence level, is represented using the caret operator, which also functions as a Knuth up-arrow operator, allowing a double-caret for tetration and even more carets for even higher-order exponentiations. Two functions, `int` and `num`, are provided for conversion to integer and number types. Python’s bitwise operations are also supported, and can be accessed via the functions `bitnot`, `bitor`, `bitand`, `bitxor`, `rshift`, and `lshift`.

### Booleans

Rabbit supports a Boolean type as well as a truth value for all Rabbit objects. Rabbit Booleans are simply Python Booleans, and Rabbit truth values function similarly to Python truth values, with 0 and all empty containers evaluating to false, and all other objects evaluating to true, unless they explicitly override their truth value. Booleans are accessed in Rabbit through the variable names `false` and `true`. The function `bool` is made available for conversion to Boolean by looking at an object’s truth value.

Multiple operators make use of Booleans. Below all of the arithmetical operators in precedence, Rabbit provides the unary prefix operators question mark and exclamation point. Question mark simply gets the truth value of the object as a Boolean, and exclamation mark does the same but gets the opposite value. Right below the unary operators in precedence, the ampersand operator returns true if all its operands have true truth values, and right below it in precedence the vertical bar operator returns true if any of its operands have true truth values. Like in Python, both of these operators are short-circuit operators—evaluation stops once the result is unambiguous. Right below the vertical bar operator in precedence, the at-symbol operator evaluates to the result of the leftmost expression of all of its right operands, evaluating starting with the rightmost, have true truth values, otherwise to null, the empty list—also short-circuiting once the result is unambiguous. This combines nicely with the operator right below it in precedence, the semicolon operator, which evaluates each of its operands left to right, stopping and returning when it reaches a value that isn’t null. Together, the at-symbol and semicolon operators form Rabbit’s conditionals, allowing for chained clauses with a catch-all at the end. Many programmers prefer these features—Boolean not, Boolean and, Boolean or, and if-then statements—to be represented in plain English. Rabbit provides that option as well through use of its automatic infix function calls, which will be specified in the function section.

Finally, right above the unary operators in precedence, and returning Booleans, there are the equality and inequality operators. Extending the idea of combining symbols for different types of comparisons together to form one big comparison, Rabbit supports a wide variety of procedurally-generated equality and inequality operators. Rabbit will look at all of the individual comparisons which are present in the operator—any of equals (represented by the equals sign), not equals (represented by Unicode not equals), less than (represented by a less than sign), and greater than (represented by a greater than sign)—and translate them into the corresponding Python comparisons. Question marks are allowed but are ignored. Exclamation points invert the result. Multiple exclamation points, not equals signs, less than signs, or greater than signs in a comparison operator are a `SyntaxError`. As many equals signs and question marks are allowed as are wanted. If no actual comparison operators, and only question marks or exclamation marks are found, a test for equality is defaulted to. To distinguish between the equals sign for variable setting and the equals sign for equality checking, one of two things must be done: either the first equals sign must be preceded by another comparison operator, or it must be followed by another comparison operator that is not also a unary operator.

### Strings

Strings in Rabbit are their own, special object, different from Python strings. Rabbit strings are always Unicode, and the basic underlying implementation uses the Python 2 unicode and Python 3 str data types. String literals in Rabbit are set off by quotation marks, and can contain Python-style backslash escapes. One notable exception is that quotation marks cannot be backslash-escaped to make them literal quotation marks. Instead, a backslash-escaped single quotation mark will insert a literal quotation mark. This is done to allow the programmer to more easily see where the string literal starts and stops by looking for quotation marks. Rabbit also supports one extra backslash-escape, backslash-minus-sign, which removes the previous character from the string literal. This is useful to allow indentation to be added without changing the string. In addition to Python character escapes, Unicode characters can also be entered directly into string literals if encoded in UTF-8. Rabbit also supports the Unicode opening and closing quotation marks as alternatives to ASCII quotation marks for enclosing strings. This has the advantage that ASCII quotation marks can be entered without needing to use backslash-escaped single quotation marks. Finally, Rabbit also supports raw string literals, where all characters are interpreted literally and no backslash escapes are evaluated, by surrounding the text with grave accents instead of quotes. For conversion to a string, the `str` function is provided.

Rabbit supports a variety of different operations on strings. Concatenation can be done via addition or the lower precedence double-plus joining operator, also used for other purposes by matrices. If concatenation is attempted with a non-string object a conversion will be attempted and then the operation performed. Concatenation can also be performed if two strings are multiplied together, a feature provided to allow string literals to be placed right next to each other to join them, as in Python. If multiplication is done by an integer or number, the string will be scaled up or down by that amount, adding in additional copies of the string if necessary. Additionally, right below the double-plus operator in precedence, strings also support the double-minus operator which, if the left operand is a string, will convert the right operands to strings and attempt to remove all occurrences of them from the left operand. Rabbit strings also support C-style formatting via the percent sign operator. Additionally, Rabbit strings also support indexing and slicing, which is accomplished using a colon followed by the arguments for the index or slice separated by colons. Index and slice numbers work as in Python with two exceptions: negative indices act as one higher than they do in Python, meaning that -1 acts like the end of the string—this is done as a replacement for Python open-ended slices which aren’t possible in Rabbit—and no step parameter is supported—if the programmer wants to reverse the string, instead of using a negative step, it is possible instead to simply use reversed indices. Finally, Rabbit strings also support all of the Python string methods, accessed, like in Python, via the dot operator.

### Matrices

Rabbit takes a unique approach to lists, using an object, the matrix, not found in Python to represent them. Rabbit’s 1-dimensional and 2-dimensional arrays are all represented internally using matrices. For 1-dimenensional arrays, Rabbit has two types, the list, and the row. Both are immutable, and the terms used to refer to them reference the way they are represented as matrices. Rows are just that—a matrix row—whereas lists are optimized diagonal matrices. That is, they function similarly to a square matrix whose main diagonal is the elements of the list. Lists, in Rabbit, are constructed similarly to how tuples are constructed in other languages, simply by separating the elements with commas. Rows, on the other hand, are constructed similarly to how lists are constructed in other languages, by enclosing the elements in brackets and separating them by commas. Two functions, `list` and `row`, are provided for conversion to each of the 1-dimensional array types. For 2-dimensional arrays, Rabbit provides the `connect` function for conversion, which behaves similarly to the `matrix` function when given multiple arguments, joining them together into one large matrix, but behaves differently with one argument, where `matrix` will convert to any type of matrix, `connect` will always convert to a 2-dimensional one.

Matrices support a variety of different operations. Matrix multiplication, scalar multiplication, and dot products for rows are all done via normal Rabbit multiplication and division. Exponentiation does matrix exponentiation, and includes support for inverses. Addition and subtraction perform matrix addition and subtraction, and for non-matrices, apply the operation to each element. The percent sign operator performs cross products when used between matrices, otherwise it is applied to each element. The double-plus operator is supported for joining matrices, and the double-minus operator is supported for removing elements. The double-asterisk operator allows for repeating a matrix, or an element, a number of times equal to the right operand. Matrices also support indexes and slices just like for strings with the one addition that slices can also use a list of two integers to represent a 2-dimensional position. Finally, matrices support many different special methods. Given the large number of special methods, they have yet to be documented, but can easily be accessed by looking at each method of the `matrix` class in `rabbit/matrix.py` that’s been decorated with the `@rabbit` syntax.

### Functions

Since Rabbit is a functional programming language, functions are arguably Rabbit’s most important data type. Functions in Rabbit can be specified in two ways—either as a definition, what’s called mathematical syntax, or in-line, what’s called lambda syntax. Mathematical syntax is done by, instead of assigning to a variable name, assign to a variable name plus a parenthesized list of arguments, where the right-hand side of the equals sign is the function body. Lambda syntax works similarly, but doesn’t require a variable name to assign to. Instead, the argument list is surrounded by backslashes and whatever code follows the closing backslash within the current precedence level is treated as the body of the function. Backslashes are chosen because they look somewhat like lambdas, and actual lambdas can be used for the same purpose but at a higher precedence level. Optional arguments can be passed by following a variable name with an equals sign and its default value. Functions in Rabbit behave somewhat differently from functions in most other languages. Since tail recursion is used in place of loops in Rabbit, all functions support tail recursion elimination. Additionally, all functions support partial application, in that if they are called with fewer arguments than they require, a function that takes the remaining arguments and then does the function will be returned. If basic arithmetical operations are performed on functions, they will be remembered, and the operation applied to the result of the function once the function is called. Rabbit functions are also lexically scoped, in that they may implicitly refer to any variables that existed when they were created. Finally, all Rabbit functions support dynamic memorization, which is off by default, but can be turned on by preceding a function’s argument list by a percent sign, and, if on, will automatically memorize the function if no side-effects were performed during the execution of the function, otherwise memorization will be avoided. For conversion to a function, the `func` function is provided.

Calling functions can be done in one of multiple different ways, each with its own special features. Parenthesis syntax allows a function to be called by placing it next to a set of parentheses containing a list of arguments. If the list contains too many arguments, the extras are combined with the last argument into another list. Colon syntax, on the other hand, is more similar to the way that functions are usually called in functional programming. The function is followed by a colon and then a colon-separated list of arguments. If too many arguments are given, the extras are applied as arguments to the result of evaluating the function on the arguments that it does take. This syntax is in fact the same as that used for indexing, but is unambiguous because functions don’t support indexing. Finally, Rabbit also supports space-separated and coefficient-separated arguments. Rabbit will use space and number-letter breaks to separate out arguments, which will then be combined by taking the first two and combining them either through parenthetical function application, if either item is a function, or multiplication, if neither are, an operation that will then be repeated over the whole list of arguments to reduce it down to one return value. This allows for Rabbit’s implicit infix syntax, since the function can be either the first or the second value—although the first is checked first. This, combined with partial application, allows for 2-argument functions to be called as binary operators placed in-between their operands.

Functions are also used in two special operators, the tilde operator and the double-dot operator. The tilde operator functions much like a more powerful combined `map`, `filter`, and `zipwith`. The rightmost operand is a function that will be fed values, and the left operands are all different containers. The number of tildes after the container signify how many items from the container to take for each iteration. In each iteration, all of the items are taken, and fed to the function to get a value. All the non-null values retrieved are then, at the end, returned as either a list, row, or string, depending on the types of the containers fed to it. The other special functional operator, the double-dot operator, is Rabbit's function composition operator, creating a new function that will first apply the functional operands in order of right to left.

### Dictionaries and Pairs

Dictionaries in Rabbit are their own special objects, but function similarly to dictionaries in Python, which are used by Rabbit dictionaries for the underlying implementation. Dictionaries in Rabbit are created by enclosing a comma-separated list of key-value pair objects in braces. Key-value pair objects are created using the hyphen-greater-than operator, used to represent an arrow, and referred to as the arrow operator. Key-value pairs, if not used inside of a dictionary, function very similarly to dictionaries with one element, but are in fact separate objects. Both key-value pairs, and the dictionaries themselves, can contain any Rabbit object, since all objects in Rabbit immutable. Values can be retrieved from a dictionary using indexing syntax where the colon argument is the key. Dictionaries support concatenation via either addition or joining—the double-plus operator—and support item removal through subtraction and pair or dictionary removal through the double-minus removal operator. Dictionaries also support a variety of methods, the most useful being `keys`, `values`, and `items`, which function the same as the equivalent methods in Python. The full list, while not yet documented, can be accessed by looking at each method of the `dictionary` class in `rabbit/func.py` that’s been decorated with the `@rabbit` syntax. Conversion to dictionaries and pairs can be done via the functions `dict` and `pair`.

### Code

Rabbit code objects are simply modified Rabbit string objects, the only difference being the type and the ability to be called—a call which results in the string being evaluated. What’s important about Rabbit code objects is the special syntactical constructs for creating them, which allow for the equivalent of statements and blocks in other languages. Thus, there are two ways of constructing code objects: block form and statement form. Block form allows any code placed between `«` and `»`, or optionally `<<` and `>>`, to be converted into a Rabbit code object. Statement form uses the double-colon operator, and functions just like the colon operator, except at a much lower precedence and that, instead of being evaluated, all the arguments are converted into Rabbit code objects. Additionally, the double-colon operator, like the double-semicolon operator, respects indentation. If no function is given, this functions similarly to block form, and one big code object is returned. Conversion to code can be done via the `code` function.

### Classes and Objects

Although Rabbit is primarily a functional programming language, it also supports object-oriented features through its classes and objects. Classes in Rabbit are created using the `class` function, which is usually called on a code object, which it executes inside the environment of the class, all assignment statements assigning to class attributes or methods. Once created, classes then support concatenation—which can be used for inheritance—via addition, joining, or multiplication and variable removal via subtraction or removal. Attributes and methods can be retrieved from classes via the dot operator, as in Python.

Classes also make possible one of Rabbit's most important constructs, the where clause. Rabbit where clauses use the dollar-sign operator, which evaluates the leftmost operand in the namespace of the class in which all of the right operands are evaluated.

Other versions of the basic class object, instances and namespaces, also exist. When normal classes are called, the result is to create an instance of that class, with the passed arguments used as arguments to the constructor. Objects of classes support all the varied operations and syntax in Rabbit, with special methods used to control how they work. To convert to an object, the function `object` is provided. Additionally, a special version of the class object, the namespace object, created with the `namespace` function,  supports calling to calculate code in the namespace of the class.

### Wrap

Rabbit’s wrap objects allow Rabbit to interface with any arbitrary Python object. These are the objects that are returned when calls are made to Rabbit’s `import` function, which functions just like Python’s import statement, but with the resulting module wrapped and returned instead of bound to a variable name. All of the operations in Rabbit are supported on these objects, and will be translated into Python operations before they are applied. Oftentimes, this requires conversion between Python objects and Rabbit objects. For conversion to a wrapper object, the function `Meta.wrap` is provided, which also allows a list of method or attribute names of the object which are pure to be passed, allowing the object to be made usable inside of pure blocks and statements. The `Meta.purify` function is also provided, which returns a wrapper with the method specified marked as pure. It should be noted that these functions don’t make the object pure, they only allow certain methods to be marked as pure. Since Rabbit can’t tell what arbitrary Python code is pure and what isn’t, it requires the programmer, if use inside of pure statements is desired, to specify what is pure and what is not.

### Other Data Types

Rabbit also supports a variety of other objects. Complex numbers are supported, and are just Python complex numbers, functioning similarly to Rabbit integers and numbers, but allowing for an imaginary part. They can be accessed via the `Math.complex` function and `Math.i` variable. Atoms are Rabbit’s form of pattern recognition, comparing true with all objects, allowing them to be put inside matrices, dictionaries, or classes to create templates that will compare true to other objects that fit the template. The atom can be accessed via the `_` variable.

### The Standard Library

In addition to supporting imports from Python’s entire standard library, Rabbit also has a large set of built-in functions. These include important comparison functions like `in`, important utility functions like `len`, and a whole host of higher-order functions including `map`, `fold`, `filter`, `zip`, and `zipwith`. Built-in classes are also supported, which contain a variety of different useful functions and variables, which can be inserted into the global namespace via the built-in function `include`. Unlike built-in variables and functions, built-in classes start with a capital letter, and include `Meta` (meta-programming utilities, including data serialization) and `Math` (mathematical functions and variables, including the complex number data type) as the two most important. While not yet documented, a full list of all built-in functions, variables, and classes can be retrieved by looking at the functions and variables created in the `fresh` method of the `evaluator` object in `rabbit/eval.py`, and the corresponding methods of the `evalfuncs` object in `rabbit/prelude.py`.
